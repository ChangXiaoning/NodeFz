#!/usr/bin/env python2

#Author: Jamie Davis (davisjam@vt.edu)
#Description: Package for transforming callback descriptions into a graph
# Defines the following public classes: 
#	 Callback
#  CallbackGraph
# Python version: 2.7.6

import logging, argparse
import Callback as CB
import gv # http://www.graphviz.org/pdf/gv.3python.pdf, http://www.graphviz.org/doc/info/attrs.html
import sys

logging.basicConfig(level=logging.INFO)
sys.setrecursionlimit(10000)

#input: (node, graph)
#output: nodeHandle corresponding to node
def getNodeHandle (node, graph):
	nodeName = "Node %s" % (node.getRegID())
	nodeHandle = gv.findnode(graph, nodeName)
	if (not nodeHandle):
		nodeHandle = gv.node(graph, "Node %s" % (node.getRegID()))
	return nodeHandle

#add NODE, its children, and a parental edge to GRAPH
#node handles for NODE and its children will be created if they do not already exist in GRAPH
#ACTION nodes will be diamonds. RESPONSE nodes will be circles.
def addNodeAndChildren (node, graph):
	assert(isinstance(node, CB.CallbackNode))
	
	nodeHandle = getNodeHandle(node, graph)
	
	#assign attributes
	extraInfo = node.getExtraInfo()
	if (extraInfo):
		extraInfo = "\\nExtra info: %s" % (extraInfo)
	else:
		extraInfo = ""
	nodeStr = "node <%s,%s> (%s,%s,%s)\\nCB type %s\\nContext %s\\nBehavior %s\\nExecuted %s %s" % (node.getRegID(), node.getExecID(), node.getTreeNumber(), node.getTreeLevel(), node.getLevelEntry(), node.getCBType(), node.getContext(), node.getBehavior(), node.executed(), extraInfo)
	gv.setv(nodeHandle, "label", nodeStr)
	
	#assign shape based on behavior
	behavior = node.getBehavior()
	if (behavior == "ACTION"):
		shape = "diamond"
	elif (behavior == "RESPONSE"):
		shape = "circle"
	else:
		shape = "square"
	gv.setv(nodeHandle, "shape", shape)
	
	#Edges: parent -> children
	for child in node.children:
		childHandle = getNodeHandle(child, graph)
		gv.edge(nodeHandle, childHandle)
	#Edges: node dependencies -> node
	for dep in node.dependencies:
		depHandle = getNodeHandle(dep, graph)
		edgeHandle = gv.edge(depHandle, nodeHandle)
		gv.setv(edgeHandle, "style", "dotted")

#Returns true if node was not executed
#For use with CallbackTree.removeNodes
def nodeNotExecuted (node):
	assert(isinstance(node, CB.CallbackNode))
	return (not node.executed())

#Returns "startTime-endTime" expressed in UNIT
#  UNIT: one of s, ms, us, ns
def cbn_getTimeRangeStr (node, unit='ns'):
	unitDivisors = {
		'ns': 1,
		'us': 1e3,
		'ms': 1e6,
		's':  1e9,
	}
	if (unit not in unitDivisors):
		assert (not "cbn_getTimeRangeStr: Error, invalid unit '%s'; select from %s" % (unit, unitDivisors.keys()))
	divisor = unitDivisors[unit]
	(start, end) = (node.getStartTime(), node.getEndTime())
	(convStart, convEnd) = (round(int(start)/divisor), round(int(end)/divisor))
	assert(convStart <= convEnd)
	return "%i-%i" % (convStart, convEnd)

def cbn_adjListStr (node):
	return "%s:%s" % (node.getRegID(), cbn_getTimeRangeStr(node, 'us'))

def walk_adjacencyList (node, f):
	if (nodeNotExecuted(node)):
		return
	myStr = cbn_adjListStr(node)
	childStrs = [cbn_adjListStr(n) for n in node.getChildren()]
	f.write("%s %s\n" % (myStr, ",".join(childStrs)))

#Returns true if node is a marker event rather than a user CB
#For use with CallbackTree.removeNodes
def nodeIsMarker (node):
	assert(isinstance(node, CB.CallbackNode))
	return node.isMarkerNode()

#Returns true if node is non-user code rather than a user CB
#For use with CallbackTree.removeNodes
def nodeIsNonUserCode (node):
	assert(isinstance(node, CB.CallbackNode))
	return (not node.isUserCode())

def addExecOrder (tree, digraph):	
	cbNodes = tree.getExecOrder()
	for i in range(0, len(cbNodes)-1):
		j = i + 1
		node1, node2 = cbNodes[i], cbNodes[j]
		#Don't draw edges for un-executed nodes
		if (node1.executed() and node2.executed()):
			h1, h2 = getNodeHandle(node1, digraph), getNodeHandle(node2, digraph)
			edgeHandle = gv.edge(h1, h2)
			gv.setv(edgeHandle, "style", "invis")

def addColors (tree, digraph, coloredNodes):
	coloredCBNodes = [n for n in tree.getExecOrder() if int(n.getRegID()) in coloredNodes]
	for n in coloredCBNodes:
		h = getNodeHandle(n, digraph)
		gv.setv(h, "style", "filled")
		gv.setv(h, "fillcolor", "red")

def main():
	parser = argparse.ArgumentParser(description="Turn a libuv event schedule into a graph in .gv and/or adjacency list format")
	parser.add_argument("--schedFile", help="file containing libuv event schedule", required=True, type=str)

	parser.add_argument("--noMarkers", help="do not include the \"marker\" nodes that indicate uv loop progress in the schedule",	action="store_true")
	parser.add_argument("--onlyUserCode", help="do not include CBs for non-user code",	action="store_true")

	parser.add_argument("--gv", help="generate gv output (provide --gvF)", action="store_true")
	parser.add_argument("--gvF", help="gv output file", type=str)
	parser.add_argument("--gvOnlyExecuted", help="only include nodes that were executed", action="store_true")
	parser.add_argument("--gvExecOrder", help="vertical position indicates relative execution order in the gv graph", action="store_true")
	parser.add_argument("--gvColorFile", help="color the nodes specified in this file (one ID per line)", type=str)

	parser.add_argument("--adj", help="generate adjacency list output (provide --adjF). includes only executed nodes", action="store_true")
	parser.add_argument("--adjF", help="adjacency list output file", type=str)

	args = parser.parse_args()

	logging.info("main: schedFile %s" % (args.schedFile))
	tree = CB.CallbackNodeTree(args.schedFile)

	if (args.noMarkers):
		logging.info("Removing marker nodes")
		tree.removeNodes(nodeIsMarker)

	if (args.onlyUserCode):
		logging.info("Removing any non-user code")
		tree.removeNodes(nodeIsNonUserCode)

	if (args.gv):
		assert(args.gvF)
		logging.info("graphviz: Generating graphviz version of schedule")

		coloredNodes = []
		if (args.gvColorFile):
			logging.info("graphviz: Reading gvColorFile %s" % (args.gvColorFile))
			try:
				with open(args.gvColorFile) as f:
					lines = f.readlines()
					coloredNodes = [int(l.rstrip()) for l in lines]
					logging.debug("graphviz: coloredNodes: %s" % (coloredNodes))
			except IOError:
				logging.error("graphviz: Reading gvColorFile %s failed" % (args.gvColorFile))
				assert(0 == 1)

		if (args.gvOnlyExecuted):
			logging.info("graphviz: Removing unexecuted nodes")
			tree.removeNodes(nodeNotExecuted)

		digraph = gv.digraph("graphviz: Creating gv graph from tree")
		tree.walk(addNodeAndChildren, digraph)

		if (args.gvExecOrder):
			logging.info("graphviz: Tweaking graph so it displays in execution order")
			addExecOrder(tree, digraph)

		if (args.gvColorFile):
			logging.info("graphviz: Adding colors")
			addColors(tree, digraph, coloredNodes)
	
		gv.write(digraph, args.gvF)
		logging.info("graphviz: Examine %s for the graphviz format" % (args.gvF))

	if (args.adj):
		assert(args.adjF)
		logging.info("adj: Generating adjacency list")

		try:
			with open(args.adjF, 'w') as f:
				tree.walk(walk_adjacencyList, f)
		except IOError:
			logging.error("adj: Writing to %s failed" % (args.adjF))
		logging.info("adj: Examine %s for the adjacency list" % (args.adjF))


###################################

main()
