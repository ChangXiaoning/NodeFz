#!/usr/bin/env python2

#Author: Jamie Davis (davisjam@vt.edu)
#Description: Package for transforming callback descriptions into a graph
# Defines the following public classes: 
#	 Callback
#  CallbackGraph
# Python version: 2.7.6

import logging, argparse
import Callback as CB
import gv # http://www.graphviz.org/pdf/gv.3python.pdf, http://www.graphviz.org/doc/info/attrs.html
import sys

logging.basicConfig(level=logging.INFO)
sys.setrecursionlimit(10000)

#input: (node, graph)
#output: nodeHandle corresponding to node
def getNodeHandle (node, graph):
	nodeName = "Node %s" % (node.getRegID())
	nodeHandle = gv.findnode(graph, nodeName)
	if (not nodeHandle):
		nodeHandle = gv.node(graph, "Node %s" % (node.getRegID()))
	return nodeHandle

#add NODE, its children, and a parental edge to GRAPH
#node handles for NODE and its children will be created if they do not already exist in GRAPH
#ACTION nodes will be diamonds. RESPONSE nodes will be circles.
def addNodeAndChildren (node, graph):
	assert(isinstance(node, CB.CallbackNode))
	
	nodeHandle = getNodeHandle(node, graph)
	
	#assign attributes
	extraInfo = node.getExtraInfo()
	if (extraInfo):
		extraInfo = "\\nExtra info: %s" % (extraInfo)
	else:
		extraInfo = ""
	nodeStr = "node <%s,%s> (%s,%s,%s)\\nCB type %s\\nContext %s\\nBehavior %s\\nExecuted %s %s" % (node.getRegID(), node.getExecID(), node.getTreeNumber(), node.getTreeLevel(), node.getLevelEntry(), node.getCBType(), node.getContext(), node.getBehavior(), node.executed(), extraInfo)
	gv.setv(nodeHandle, "label", nodeStr)
	
	#assign shape based on behavior
	behavior = node.getBehavior()
	if (behavior == "ACTION"):
		shape = "diamond"
	elif (behavior == "RESPONSE"):
		shape = "circle"
	else:
		shape = "square"
	gv.setv(nodeHandle, "shape", shape)
	
	#Edges: parent -> children
	for child in node.children:
		childHandle = getNodeHandle(child, graph)
		gv.edge(nodeHandle, childHandle)
	#Edges: node dependencies -> node
	for dep in node.dependencies:
		depHandle = getNodeHandle(dep, graph)
		edgeHandle = gv.edge(depHandle, nodeHandle)
		gv.setv(edgeHandle, "style", "dotted")

#Returns true if node was not executed
#For use with CallbackTree.removeNodes
def nodeNotExecuted (node):
	assert(isinstance(node, CB.CallbackNode))
	return (not node.executed())

#Returns "startTime-endTime" expressed in UNIT
#  UNIT: one of s, ms, us, ns
def cbn_getTimeRangeStr (node, unit='ns'):
	unitDivisors = {
		'ns': 1,
		'us': 1e3,
		'ms': 1e6,
		's':  1e9,
	}
	if (unit not in unitDivisors):
		assert (not "cbn_getTimeRangeStr: Error, invalid unit '%s'; select from %s" % (unit, unitDivisors.keys()))
	divisor = unitDivisors[unit]
	(start, end) = (node.getStartTime(), node.getEndTime())
	(convStart, convEnd) = (round(int(start)/divisor), round(int(end)/divisor))
	assert(convStart <= convEnd)
	return "%i-%i" % (convStart, convEnd)

def cbn_adjListStr (node):
	return "%s:%s" % (node.getRegID(), cbn_getTimeRangeStr(node, 'us'))

def walk_adjacencyList (node, arg):
	if (nodeNotExecuted(node)):
		return
	myStr = cbn_adjListStr(node)
	childStrs = [cbn_adjListStr(n) for n in node.getChildren()]
	print "%s %s" % (myStr, ",".join(childStrs))

#Returns true if node is a marker event rather than a user CB
#For use with CallbackTree.removeNodes
def nodeIsMarker (node):
	assert(isinstance(node, CB.CallbackNode))
	return node.isMarkerNode()

def addExecOrder (tree, digraph):	
	cbNodes = tree.getExecOrder()
	for i in range(0, len(cbNodes)-1):
		j = i + 1
		node1, node2 = cbNodes[i], cbNodes[j]
		#Don't draw edges for un-executed nodes
		if (node1.executed() and node2.executed()):
			h1, h2 = getNodeHandle(node1, digraph), getNodeHandle(node2, digraph)
			edgeHandle = gv.edge(h1, h2)
			gv.setv(edgeHandle, "style", "invis")

def addColors (tree, digraph, coloredNodes):
	coloredCBNodes = [n for n in tree.getExecOrder() if int(n.getRegID()) in coloredNodes]
	for n in coloredCBNodes:
		h = getNodeHandle(n, digraph)
		gv.setv(h, "style", "filled")
		gv.setv(h, "fillcolor", "red")

def main():
	parser = argparse.ArgumentParser(description="Turn a libuv event schedule into a graph (.gv)")
	parser.add_argument("cbFile", help="file describing events")
	parser.add_argument("outputFile", help="file describing events")
	parser.add_argument("--onlyExecuted", help="only display nodes that were executed", action="store_true")
	parser.add_argument("--noMarkers", help="do not display the \"marker\" nodes that indicate uv loop progress", action="store_true")
	parser.add_argument("--execOrder", help="vertical position indicates relative execution order", action="store_true")
	parser.add_argument("--adjList", help="print an adjacency list representation", action="store_true")
	parser.add_argument("--colorFile", help="Color the nodes specified in this file (one ID per line)", type=str)

	args = parser.parse_args()
	
	logging.info("args.cbFile %s args.outputFile %s" % (args.cbFile, args.outputFile))
	tree = CB.CallbackNodeTree(args.cbFile)

	coloredNodes = []
	if (args.colorFile):
		logging.info("Reading colorFile %s" % (args.colorFile))
		try:
			with open(args.colorFile) as f:
				lines = f.readlines()
				coloredNodes = [int(l.rstrip()) for l in lines]
				logging.debug("coloredNodes: %s" % (coloredNodes))
		except IOError:
			logging.error("Reading colorFile %s failed" % (args.colorFile))
			assert(0 == 1)

	if (args.onlyExecuted):
		logging.info("Removing unexecuted nodes")
		tree.removeNodes(nodeNotExecuted)

	if (args.noMarkers):
		logging.info("Removing marker nodes")
		tree.removeNodes(nodeIsMarker)
	
	digraph = gv.digraph("Creating gv graph from tree")
	tree.walk(addNodeAndChildren, digraph)

	if (args.execOrder):
		logging.info("Tweaking graph so it displays in execution order")
		addExecOrder(tree, digraph)

	if (args.colorFile):
		logging.info("Adding colors")
		addColors(tree, digraph, coloredNodes)
	
	gv.write(digraph, args.outputFile)
	logging.info("Check %s for results" % (args.outputFile))

	if (args.adjList):
		logging.info("Adjacency list:")
		tree.walk(walk_adjacencyList, None)

###################################

main()
