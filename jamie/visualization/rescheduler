#!/usr/bin/env python2

# Author: Jamie Davis (davisjam@vt.edu)
# Description: Script for transforming libuv event schedules: "rescheduling" to flip the order of events in a legal way
# Python version: 2.7.6

import argparse
import copy
import logging
import re
import sys

import Schedule

logging.basicConfig(level=logging.INFO)
sys.setrecursionlimit(100000)

# input: (raceFile)
# Sample file contents:
# Color 1
# 2
# 3
# Color 2
# 4
# 7
# 9
# Color 3
# ...
# output: List of lists. Each list corresponds to a new set of nodes to race.
# Throws any errors it encounters during file IO
def parseRaceFile(raceFile):
	nodeLists = []
	foundGroup = False
	with open(raceFile) as f:
		raceGroup = []
		for line in f:
			line = line.rstrip()
			logging.debug("parseRaceFile: line <%s>" % (line))
			# Ignore whitespace and lines beginning with a #
			if (re.match('^\s*$', line) or re.match('^\s*#', line)):
				continue
			if (re.match('^\s*Color \d', line)):
				foundGroup = True
				# New raceGroup
				if (raceGroup):
					logging.debug("parseRaceFile: raceGroup <%s>" % (raceGroup))
					nodeLists.append(raceGroup)
				raceGroup = []
			else:
				# Add to raceGroup
				assert(re.match('^\s*\d+\s*$', line))
				raceGroup.append(int(line.rstrip()))

		if (raceGroup):
			logging.debug("parseRaceFile: raceGroup <%s>" % (raceGroup))
			nodeLists.append(raceGroup)

	assert(foundGroup)
	return nodeLists


def main():
	parser = argparse.ArgumentParser(description="Produce schedules to explore races")
	parser.add_argument("--schedFile", help="file containing libuv event schedule", required=True, type=str)	
	parser.add_argument("--raceFile", help="Set of racey nodes (format: 'race i' followed by one reg ID per line)", required=True, type=str)
	parser.add_argument("--outputPrefix", help="save schedules to outputPrefix_i, one for each race in raceFile", type=str, default="raceySchedule")

	args = parser.parse_args()

	logging.info("schedFile {} raceFile {} outputPrefix {}".format(args.schedFile, args.raceFile, args.outputPrefix))

	logging.info("Loading the callback cbTree from schedFile {}".format(args.schedFile))
	origSchedule = Schedule.Schedule(args.schedFile)

	try:
		logging.info("Loading the races from raceFile {}".format(args.raceFile))
		raceyNodes = parseRaceFile(args.raceFile)
	except IOError:
		logging.error("Error, reading raceFile {} failed".format(args.raceFile))
		raise

	for (ix, race) in enumerate(raceyNodes):
		outFile = "{}_{}".format(args.outputPrefix, ix)
		logging.info("Generating schedule for race <{}>".format(race))
		scheduleCopy = copy.deepcopy(origSchedule)
		try:
			idMap = scheduleCopy.reschedule(race)
			logging.info("The schedule from race <{}> is going into outFile {}".format(race, outFile))
			logging.info("ID map:")
			for i in idMap:
				logging.info("  {} -> {}".format(i, idMap[i]))
			scheduleCopy.emit(outFile)
		except Schedule.ScheduleException as se:
			logging.info("Sorry, could not achieve race <{}>: {}".format(race, se))
		except IOError:
			logging.error("Error, could not write schedule to file <{}>".format(outFile))
			raise

###################################

main()
