#!/usr/bin/env python2

#Author: Jamie Davis (davisjam@vt.edu)
#Description: Script for transforming libuv event schedules: "rescheduling" to flip the order of events in a legal way
# Python version: 2.7.6

import logging, argparse, sys, re, copy

import Callback as CB
import Schedule

logging.basicConfig(level=logging.DEBUG)
sys.setrecursionlimit(100000)

#add NODE, its children, and a parental edge to GRAPH
#node handles for NODE and its children will be created if they do not already exist in GRAPH
#ACTION nodes will be diamonds. RESPONSE nodes will be circles.
def addNodeAndChildren (node, graph):
	assert(isinstance(node, CB.CallbackNode))
	
	nodeHandle = getNodeHandle(node, graph)
	
	#assign attributes
	extraInfo = node.getExtraInfo()
	if (extraInfo):
		extraInfo = "\\nExtra info: %s" % (extraInfo)
	else:
		extraInfo = ""
	nodeStr = "node <%s,%s> (%s,%s,%s)\\nCB type %s\\nContext %s\\nBehavior %s\\nExecuted %s %s" % (node.getRegID(), node.getExecID(), node.getTreeNumber(), node.getTreeLevel(), node.getLevelEntry(), node.getCBType(), node.getContext(), node.getBehavior(), node.executed(), extraInfo)
	gv.setv(nodeHandle, "label", nodeStr)
	
	#assign shape based on behavior
	behavior = node.getBehavior()
	if (behavior == "ACTION" or behavior == "RESPONSE"):
		# All user code is put in squares so that the 'striped' style works
		shape = "square"
	else:
		shape = "diamond"
	gv.setv(nodeHandle, "shape", shape)
	
	#Edges: parent -> children
	for child in node.children:
		childHandle = getNodeHandle(child, graph)
		gv.edge(nodeHandle, childHandle)
	#Edges: node dependencies -> node
	for dep in node.dependencies:
		depHandle = getNodeHandle(dep, graph)
		edgeHandle = gv.edge(depHandle, nodeHandle)
		gv.setv(edgeHandle, "style", "dotted")

#Returns true if node was not executed
#For use with CallbackTree.removeNodes
def nodeNotExecuted (node):
	assert(isinstance(node, CB.CallbackNode))
	return (not node.executed())

#Returns true if node is a marker event rather than a user CB
#For use with CallbackTree.removeNodes
def nodeIsMarker (node):
	assert(isinstance(node, CB.CallbackNode))
	return node.isMarkerNode()

#Returns true if node is non-user code rather than a user CB
#For use with CallbackTree.removeNodes
def nodeIsNonUserCode (node):
	assert(isinstance(node, CB.CallbackNode))
	return (not node.isUserCode())

# input: (raceFile)
#		Sample file contents:
# Color 1
# 2
# 3
# Color 2
# 4
# 7
# 9
# Color 3
# ...
# output: List of lists. Each list corresponds to a new set of nodes to race.
# Throws any errors it encounters during file IO
def parseRaceFile (raceFile):
	nodeLists = []
	foundGroup = 0
	with open(raceFile) as f:
		raceGroup = []
		for line in f:
			line = line.rstrip()
			logging.debug("parseRaceFile: line <%s>" % (line))
			# Ignore whitespace and lines beginning with a #
			if (re.match('^\s*$', line) or re.match('^\s*#', line)):
				continue
			if (re.match('^\s*Color \d', line)):
				foundGroup = 1
				# New raceGroup
				if (raceGroup):
					logging.debug("parseRaceFile: raceGroup <%s>" % (raceGroup))
					nodeLists.append(raceGroup)
				raceGroup = []
			else:
				# Add to raceGroup
				assert(re.match('^\s*\d+\s*$', line))
				raceGroup.append(int(line.rstrip()))

		if (raceGroup):
			logging.debug("parseRaceFile: raceGroup <%s>" % (raceGroup))
			nodeLists.append(raceGroup)

	assert(foundGroup)
	return nodeLists

def main():
	parser = argparse.ArgumentParser(description="Produce schedules to explore races")
	parser.add_argument("--schedFile", help="file containing libuv event schedule", required=True, type=str)	
	parser.add_argument("--raceFile", help="Set of racey nodes (format: 'race i' followed by one reg ID per line)", required=True, type=str)
	parser.add_argument("--outputPrefix", help="save schedules to outputPrefix_i, one for each race in raceFile", type=str, default="raceySchedule")

	args = parser.parse_args()

	logging.info("schedFile %s raceFile %s outputPrefix %s" % (args.schedFile, args.raceFile, args.outputPrefix))

	logging.info("Loading the callback cbTree from schedFile %s" % (args.schedFile))
	origSchedule = Schedule.Schedule(args.schedFile)

	try:
		logging.info("Loading the races from raceFile %s" % (args.raceFile))
		raceyNodes = parseRaceFile(args.raceFile)
	except IOError:
		logging.error("Error, reading raceFile %s failed" % (args.raceFile))
		assert(0 == 1)
	
	for (ix, race) in enumerate(raceyNodes):
		outFile = "%s_%d" % (args.outputPrefix, ix)
		logging.info("Generating schedule for race <%s>" % (race))
		scheduleCopy = copy.deepcopy(origSchedule)
		try:
			scheduleCopy.reschedule(race)
	 		logging.info("The schedule from race <%s> is going into outFile %s" % (race, outFile))
	 		scheduleCopy.emit(outFile)
	 	except Schedule.ScheduleException as se:
	 		logging.info("Sorry, could not achieve race <%s>: %s" % (race, se))
	 	except IOError:
	 		logging.error("Error, could not write schedule to file <%s>" % (outFile))

###################################

main()